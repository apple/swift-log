# Metadata Providers

## Introduction

While global metadata attributes may be manually set on a `LogHandler` level,
there's currently no way of providing runtime-generated metadata on a global level.

## Motivation

To benefit from tools such as [Distributed Tracing](https://github.com/apple/swift-distributed-tracing) it is of great
importance that all logs include runtime-generated metadata such as a trace ID. This allows for patterns such as
automatic log correlation.

The only currently supported way of providing such metadata is to pass them along to each log call explicitly:

```swift
let traceID = "my-awesome-trace-id"
logger.info("first this ...", metadata: ["trace-id": traceID])
logger.info("... now this", metadata: ["trace-id": traceID])
```

This comes with a couple of downsides:

### Easy to forget for end-users

It's easy to forget passing this metadata to all log statements, resulting in an inconsistent debugging
experience in the case of Distributed Tracing which doesn't paint the full picture.

### Impossible to implement for libraries

A large portion of logs are not generated by the end-user but by libraries such as AsyncHTTPClient, Vapor etc.
These libraries don't necesarilly have access to the elsewhere runtime-generated metadata that should be included in
their logs as well.

For example, a specific `Tracer` implementation would use a type representing a trace ID, and has a way of extracting
that trace ID from a `Baggage`. But other libraries don't know about this specific trace ID so would inherently not be
able to pass such values along to their log statements.

## Proposed solution

To support this kind of runtime-generated metadata in `swift-log`, a new API is needed. Our proposed API is called
_metadata providers_, which boils down to a function with the following signature:

```swift
(Baggage?) -> Metadata?
```

### Using Baggage as the metadata container

This proposal also includes adding a dependency
on [Swift Distributed Tracing Baggage](https://github.com/apple/swift-distributed-tracing-baggage) to be used as the
container passed to these metadata providers.

<!-- TODO: Explain why we want to use Baggage -->

The end-user configures a metadata provider on a specific `Logger` via a new initializer parameter:

```swift
let logger = Logger(label: "example", metadataProvider: { baggage in
    // extract values from baggage
    guard let traceID = baggage?[TraceIDKey.self] else { return nil }
    // convert values into logging metadata
    return ["trace-id": traceID]
})
```

### Task-local Baggage

Once configured, the `log` function and its log-level-based counterparts will utilize this provider by merging the
provided metadata with the one-off metadata within the log statement:

```swift
extension Logger {
    // unrelated code location parameters left out
    func log(level: Logger.Level,
        _ message: @autoclosure () -> Logger.Message,
        metadata: @autoclosure () -> Logger.Metadata? = nil,
        baggage: Baggage? = .current) {
    } {
        // implementation
    }
}

var baggage = Baggage.topLevel
baggage[TestIDKey.self] = "my-awesome-trace-id"
Baggage.$current.withValue(baggage) {
    logger.log(level: .info, "example", metadata: ["one-off": "example"])
    // passes both "one-off" and "trace-id" metadata to the log handler
}
```

This has the advantage of not having to specify the global metadata explicitly anymore. It also solves the issue of
libraries not being able to include this kind of metadata since it is done automatically in the background, as long as
the values are stored inside the task-local `Baggage`.

### Explicitly passing Baggage

Some libraries currently provide an `async` API shell around a mostly NIO-based internal implementation. The proposed
strategy for such libraries is to capture the task-local `Baggage` within the `async` API, then pass it along inside the
NIO-based internals, and finally pass this `Baggage` along to their log statements.
