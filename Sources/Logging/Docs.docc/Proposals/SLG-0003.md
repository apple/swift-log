# SLG-0003: Standardized Error Metadata via Logger Convenience

Add standardized way of attaching data from `Error` instances to log posts.

## Overview

- Proposal: SLG-0003
- Author(s): [Samuel Murray](https://github.com/samuelmurray)
- Status: **Awaiting Review**
- Issue: [apple/swift-log#291](https://github.com/apple/swift-log/issues/291)
- Implementation:
    - [apple/swift-log#406](https://github.com/apple/swift-log/pull/406)
- Related links:
    - [Lightweight proposals process description](https://github.com/apple/swift-log/blob/main/Sources/Logging/Docs.docc/Proposals/Proposals.md)
    - [First attempt at solution](https://github.com/apple/swift-log/pull/384)

### Introduction

Add convenience methods on `Logger` that accepts an `Error` instance, which get serialized into `MetadataValue`s in a predefined way.

### Motivation

SwiftLog advocates for the use of _structured logging_, which in its implementation is achieved by using the `metadata` attribute in the log methods. This is important since it allows for automated tools to parse the logs and extract metadata values for filtering and/or visualization. When logging in a catch-block, it often makes sense to attach some information from the thrown `Error` in the log post, so as to capture the root cause.

```swift
do {
    try someThrowingFunc()
} catch {
    logger.warning("Something went wrong") // Want to somehow attach information about the error
}
```

Currently, there is no standardized way of doing this. The simplest way to do it would be to simply attach the stringified error to the message.

```swift
logger.warning("Something went wrong: \(error)")
```

This of course is not _structured_, so a better way would be:

```swift
logger.warning("Something went wrong", metadata: ["error": "\(error)"])
```

However, since there is no clear preference for what metadata key to use, it is likely that different code bases use variations of the above. This makes it hard for automated tools to extract error information, since there is no single key to look for.

Additionally, there is more information that we could extract from the error, such as the type name.

```swift
logger.warning("Something went wrong", metadata: ["error.message": "\(error)", "error.type": "\(String(reflecting: type(of: error)))"])
```

The above is a reasonable way to log a generic error, but it is unlikely that everyone will use the same metadata keys. It is also quite a lot of code, for something that feels like it should be easy to do - i.e. attach an error to a log.

Finally, even if you log errors in a consistent way in your code, you do not control logs generated in other modules/packages that you call. In practice, this makes it so that different parts of your application could log error information under different keys, which, again, makes it harder for tooling.

### Proposed solution

The solution we propose is to add convenience methods in `Logger` that allows the caller to do the following:

```swift
do {
    try someThrowingFunc()
} catch {
    logger.warning("Something went wrong", error: error)
}
```

This would serialize the error, by stringifying it and extracting the fully qualified type name. This information is added as metadata, merging it with any metadata passed to the `metadata`-parameter. Under the hood, an existing log function is called with the merged metadata. We propose that such convenience methods are added for all log methods (even if it arguably makes less sense for e.g. `trace` and `debug` than `warning`). 

There are two clear gains from this:

* It is obvious for the caller _how_ to attach an `Error` to a log (and the caller code also looks cleaner)
* We get a consistent format for logged errors

Additionally, we propose to add a convenience method on `Logger` to allow the caller to attach error metadata on the logger instance:

```swift
do {
    try someThrowingFunc()
} catch {
    logger.recordError(error)
    logger.warning("Something went wrong")
}
```

Similarly to the new logging methods, this would serialize the error and add it as metadata on the logger. This is especially useful if multiple log statements are made, or the logger is passed to other functions where the error metadata is relevant.

Of course, it might take time for this feature to be widely adopted, but the proposed solution is fully backwards compatible, meaning there is no added downside of having some parts of your code calling the new convenience methods, and other parts manually attaching an error.

### Detailed design

The proposed solution is to add a new overload for each log method (`trace`, ..., `critical`) that accepts an `Error` as its second argument, as well as a new overload for `Logger.log`, that accepts an `Error` as its third argument. Similarly, we add a method `recordError` to attach an `Error` as metadata to a logger instance.

```swift
extension Logger {
    /// Log a message at the 'trace' log level with the source that you provide.
    ///
    /// If ``Level/trace`` is at least as severe as this logger's ``logLevel`` the system logs the message;
    /// otherwise nothing will happen.
    ///
    /// - parameters:
    ///    - message: The message to be logged. The `message` parameter supports any string interpolation literal.
    ///    - error: An `Error` related to the event.
    ///    - metadata: One-off metadata to attach to this log message.
    ///    - source: The source this log message originates from. The value defaults
    ///              to the module that emits the log message.
    ///    - file: The file this log message originates from. There's usually no need to pass it explicitly, as it
    ///            defaults to `#fileID`.
    ///    - function: The function this log message originates from. There's usually no need to pass it explicitly, as
    ///                it defaults to `#function`.
    ///    - line: The line this log message originates from. There's usually no need to pass it explicitly, as it
    ///            defaults to `#line`.
    @inlinable
    public func trace(
        _ message: @autoclosure () -> Logger.Message,
        error: any Error,
        metadata: @autoclosure () -> Logger.Metadata? = nil,
        source: @autoclosure () -> String? = nil,
        file: String = #fileID,
        function: String = #function,
        line: UInt = #line
    )
    /// Log a message at the 'debug' log level with the source that you provide.
    ///
    /// If ``Level/debug`` is at least as severe as this logger's ``logLevel`` the system logs the message;
    /// otherwise nothing will happen.
    ///
    /// - parameters:
    ///    - message: The message to be logged. The `message` parameter supports any string interpolation literal.
    ///    - error: An `Error` related to the event.
    ///    - metadata: One-off metadata to attach to this log message.
    ///    - source: The source this log message originates from. The value defaults
    ///              to the module that emits the log message.
    ///    - file: The file this log message originates from. There's usually no need to pass it explicitly, as it
    ///            defaults to `#fileID`.
    ///    - function: The function this log message originates from. There's usually no need to pass it explicitly, as
    ///                it defaults to `#function`.
    ///    - line: The line this log message originates from. There's usually no need to pass it explicitly, as it
    ///            defaults to `#line`.
    @inlinable
    public func debug(
        _ message: @autoclosure () -> Logger.Message,
        error: any Error,
        metadata: @autoclosure () -> Logger.Metadata? = nil,
        source: @autoclosure () -> String? = nil,
        file: String = #fileID,
        function: String = #function,
        line: UInt = #line
    )

    /// Log a message at the 'info' log level with the source that you provide.
    ///
    /// If ``Level/info`` is at least as severe as this logger's ``logLevel`` the system logs the message;
    /// otherwise nothing will happen.
    ///
    /// - parameters:
    ///    - message: The message to be logged. The `message` parameter supports any string interpolation literal.
    ///    - error: An `Error` related to the event.
    ///    - metadata: One-off metadata to attach to this log message.
    ///    - source: The source this log message originates from. The value defaults
    ///              to the module that emits the log message.
    ///    - file: The file this log message originates from. There's usually no need to pass it explicitly, as it
    ///            defaults to `#fileID`.
    ///    - function: The function this log message originates from. There's usually no need to pass it explicitly, as
    ///                it defaults to `#function`.
    ///    - line: The line this log message originates from. There's usually no need to pass it explicitly, as it
    ///            defaults to `#line`.
    @inlinable
    public func info(
        _ message: @autoclosure () -> Logger.Message,
        error: any Error,
        metadata: @autoclosure () -> Logger.Metadata? = nil,
        source: @autoclosure () -> String? = nil,
        file: String = #fileID,
        function: String = #function,
        line: UInt = #line
    )

    /// Log a message at the 'notice' log level with the source that you provide.
    ///
    /// If ``Level/notice`` is at least as severe as this logger's ``logLevel`` the system logs the message;
    /// otherwise nothing will happen.
    ///
    /// - parameters:
    ///    - message: The message to be logged. The `message` parameter supports any string interpolation literal.
    ///    - error: An `Error` related to the event.
    ///    - metadata: One-off metadata to attach to this log message.
    ///    - source: The source this log message originates from. The value defaults
    ///              to the module that emits the log message.
    ///    - file: The file this log message originates from. There's usually no need to pass it explicitly, as it
    ///            defaults to `#fileID`.
    ///    - function: The function this log message originates from. There's usually no need to pass it explicitly, as
    ///                it defaults to `#function`.
    ///    - line: The line this log message originates from. There's usually no need to pass it explicitly, as it
    ///            defaults to `#line`.
    @inlinable
    public func notice(
        _ message: @autoclosure () -> Logger.Message,
        error: any Error,
        metadata: @autoclosure () -> Logger.Metadata? = nil,
        source: @autoclosure () -> String? = nil,
        file: String = #fileID,
        function: String = #function,
        line: UInt = #line
    )

    /// Log a message at the 'warning' log level with the source that you provide.
    ///
    /// If ``Level/warning`` is at least as severe as this logger's ``logLevel`` the system logs the message;
    /// otherwise nothing will happen.
    ///
    /// - parameters:
    ///    - message: The message to be logged. The `message` parameter supports any string interpolation literal.
    ///    - error: An `Error` related to the event.
    ///    - metadata: One-off metadata to attach to this log message.
    ///    - source: The source this log message originates from. The value defaults
    ///              to the module that emits the log message.
    ///    - file: The file this log message originates from. There's usually no need to pass it explicitly, as it
    ///            defaults to `#fileID`.
    ///    - function: The function this log message originates from. There's usually no need to pass it explicitly, as
    ///                it defaults to `#function`.
    ///    - line: The line this log message originates from. There's usually no need to pass it explicitly, as it
    ///            defaults to `#line`.
    @inlinable
    public func warning(
        _ message: @autoclosure () -> Logger.Message,
        error: any Error,
        metadata: @autoclosure () -> Logger.Metadata? = nil,
        source: @autoclosure () -> String? = nil,
        file: String = #fileID,
        function: String = #function,
        line: UInt = #line
    )

    /// Log a message at the 'error' log level with the source that you provide.
    ///
    /// If ``Level/error`` is at least as severe as this logger's ``logLevel`` the system logs the message;
    /// otherwise nothing will happen.
    ///
    /// - parameters:
    ///    - message: The message to be logged. The `message` parameter supports any string interpolation literal.
    ///    - error: An `Error` related to the event.
    ///    - metadata: One-off metadata to attach to this log message.
    ///    - source: The source this log message originates from. The value defaults
    ///              to the module that emits the log message.
    ///    - file: The file this log message originates from. There's usually no need to pass it explicitly, as it
    ///            defaults to `#fileID`.
    ///    - function: The function this log message originates from. There's usually no need to pass it explicitly, as
    ///                it defaults to `#function`.
    ///    - line: The line this log message originates from. There's usually no need to pass it explicitly, as it
    ///            defaults to `#line`.
    @inlinable
    public func error(
        _ message: @autoclosure () -> Logger.Message,
        error: any Error,
        metadata: @autoclosure () -> Logger.Metadata? = nil,
        source: @autoclosure () -> String? = nil,
        file: String = #fileID,
        function: String = #function,
        line: UInt = #line
    )

    /// Log a message at the 'critical' log level with the source that you provide.
    ///
    /// If ``Level/critical`` is at least as severe as this logger's ``logLevel`` the system logs the message;
    /// otherwise nothing will happen.
    ///
    /// - parameters:
    ///    - message: The message to be logged. The `message` parameter supports any string interpolation literal.
    ///    - error: An `Error` related to the event.
    ///    - metadata: One-off metadata to attach to this log message.
    ///    - source: The source this log message originates from. The value defaults
    ///              to the module that emits the log message.
    ///    - file: The file this log message originates from. There's usually no need to pass it explicitly, as it
    ///            defaults to `#fileID`.
    ///    - function: The function this log message originates from. There's usually no need to pass it explicitly, as
    ///                it defaults to `#function`.
    ///    - line: The line this log message originates from. There's usually no need to pass it explicitly, as it
    ///            defaults to `#line`.
    @inlinable
    public func critical(
        _ message: @autoclosure () -> Logger.Message,
        error: any Error,
        metadata: @autoclosure () -> Logger.Metadata? = nil,
        source: @autoclosure () -> String? = nil,
        file: String = #fileID,
        function: String = #function,
        line: UInt = #line
    )

    /// Log a message using the log level and source that you provide.
    ///
    /// If the `logLevel` passed to this method is more severe than the `Logger`'s ``logLevel``, the library
    /// logs the message, otherwise nothing will happen.
    ///
    /// - parameters:
    ///    - level: The severity level of the `message`.
    ///    - message: The message to be logged. The `message` parameter supports any string interpolation literal.
    ///    - error: An `Error` related to the event.
    ///    - metadata: One-off metadata to attach to this log message.
    ///    - source: The source this log message originates from. The value defaults
    ///              to the module that emits the log message.
    ///    - file: The file this log message originates from. There's usually no need to pass it explicitly, as it
    ///            defaults to `#fileID`.
    ///    - function: The function this log message originates from. There's usually no need to pass it explicitly, as
    ///                it defaults to `#function`.
    ///    - line: The line this log message originates from. There's usually no need to pass it explicitly, as it
    ///            defaults to `#line`.
    @inlinable
    public func log(
        level: Logger.Level,
        _ message: @autoclosure () -> Logger.Message,
        error: any Error,
        metadata: @autoclosure () -> Logger.Metadata? = nil,
        source: @autoclosure () -> String? = nil,
        file: String = #fileID,
        function: String = #function,
        line: UInt = #line
    )

    /// Add an error as logging metadata.
    ///
    /// > Note: Changing the logging metadata only affects the instance of the `Logger` where you change it.
    @inlinable
    public mutating func recordError(_ error: any Error)
}
```

Calling any of the new methods will serialize the `Error`, extracting its string representation and fully qualified type name. These are added as metadata under the keys `"error.message"` and `"error.type"` respectively. A draft implementation can be found in [apple/swift-log#406](https://github.com/apple/swift-log/pull/406).

We choose the keys `"error.message"` and `"error.type"` since they correspond to what [ECS](https://www.elastic.co/docs/reference/ecs/ecs-error) and [OpenTelemetry](https://opentelemetry.io/docs/specs/semconv/registry/attributes/error/#error-type) use.

We propose that the metadata keys used should be considered stable and part of the `swift-log` API. This makes it so that `LogHandler`s can reliably access this information. This is useful if a `LogHandler` wants to output the logs in a format which uses other keys for error information (e.g. re-map the error to `"err.message"` and `"err.type"`). To facilitate this, we suggest adding these as public static properties.

```swift
extension Logger {
    /// Metadata keys with specific use-cases.
    public struct WellKnownMetadataKey: String {
        /// If an `Error` is passed to ``Logger/log(level:_:error:metadata:source:file:function:line:)``, this metadata entry will contain its string representation.
        public static let errorMessage = "error.message"
        /// If an `Error` is passed to ``Logger/log(level:_:error:metadata:source:file:function:line:)``, this metadata entry will contain its fully qualified type name.
        public static let errorType = "error.type"

        private init() {
            // Private init to prevent initialization
        }
    }
}
```

This also makes it easier to promote that these keys are part of the `swift-log` API. However, it should be noted that users of `Logger` are still allowed to use these keys manually. That is, the following is still valid.

```swift
logger.warning("Valid log", metadata: ["error.message": ["msg1", "msg2"]])
```

This suggests that a `LogHandler` that wants to extract error information from the metadata must ensure that the expected types are passed. For example, it could opt to re-map any error metadata that contain only strings, and leave any other metadata using those keys untouched.

### API stability

The proposed additions are fully backwards compatible, meaning that all existing code will continue to function as is. Additionally, a user of `Logger` can start using the new convenience methods, without any modifications of the `LogHandler`, since a `LogHandler` is already expected to handle `Metadata`. 

A potential metadata collision exists when an `Error` is passed via the new methods while the same keys (`"error.message"`, `"error.type"`) are present in metadata:

```swift
logger.warning("Something went wrong", error: error, metadata: ["error.message": "some other info"])
```

We recommend that the `error` parameter takes precedence in such cases, with conflicting metadata values discarded. This aligns with the principle that explicit `error:` parameters represent primary data, while the same keys in metadata are likely incidental. In practice, we don't expect callers to deliberately pass conflicting error information.

### Future directions

A future extension of this could be to pass raw `Error` objects to `LogHandler`s. This would allow them to extract more (or less) information from the `Error`, and serialize it however they want. One could imagine that such an extension would come with a default implementation similar to that in this proposal, so that existing `LogHandler`s would be unaffected.

This would however affect the abstraction layer between `Logger` and `LogHandler`, and so would need a strong justification.

### Alternatives considered

#### WellKnownMetadataKey as enum

It was considered to make `WellKnownMetadataKey` an enum, but seeing as more keys might be added in the future, this enum would have had to be marked `@nonexhaustive` to not make such addition a breaking change. However, using this attribute would limit which Swift versions are supported by `swift-log`, and so was not a good option.

#### Pass raw Error objects to LogHandler

An alternative would be to pass the `Error` objects directly to the `LogHandler` (as discussed in **"Future directions"**). This was the solution initially proposed in [apple/swift-log#384](https://github.com/apple/swift-log/pull/384). 

The API in `Logger` would be the same, adding new extensions methods that take an `Error` as a parameter, but would also allow a `LogHandler` to directly access the `Error` instance. 

```swift
struct CustomLogHandler: LogHandler {
    public func log(
        level: Logger.Level,
        message: Logger.Message,
        error: any Error?, // New parameter
        metadata: Logger.Metadata?,
        source: String,
        file: String,
        function: String,
        line: UInt
    ) {
        // process log post and serialize error however you like
    }
}
```

This was rejected due to breaking the existing abstraction layer between `Logger` and `LogHandler`, while also being questionable how much value it would add.