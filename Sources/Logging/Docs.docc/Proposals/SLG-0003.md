# SLG-0003: Standardized Error Metadata via Logger Convenience

Add standardized way of attaching data from `Error` instances to log posts.

## Overview

- Proposal: SLG-0003
- Author(s): [Samuel Murray](https://github.com/samuelmurray)
- Status: **Awaiting Review**
- Issue: [apple/swift-log#291](https://github.com/apple/swift-log/issues/291)
- Implementation:
    - TBD
- Related links:
    - [Lightweight proposals process description](https://github.com/apple/swift-log/blob/main/Sources/Logging/Docs.docc/Proposals/Proposals.md)
    - [First attempt at solution](https://github.com/apple/swift-log/pull/384)

### Introduction

Add convenience methods on `Logger` that accepts an `Error` instance, which get serialized into `MetadataValue`s in a predefined way.

### Motivation

SwiftLog advocates for the use of _structured logging_, which in its implementation is achieved by using the `metadata` attribute in the log methods. This is important since it allows for automated tools to parse the logs and extract metadata values for filtering and/or visualization. When logging in a catch-block, it often makes sense to attach some information from the thrown `Error` in the log post, so as to capture the root cause.

```swift
do {
    try someThrowingFunc()
} catch {
    logger.warning("Something went wrong") // Want to somehow attach information about the error
}
```

Currently, there is no standardized way of doing this. The simplest way to do it would be to simply attach the stringified error to the message.

```swift
logger.warning("Something went wrong: \(error)")
```

This of course is not _structured_, so a better way would be:

```swift
logger.warning("Something went wrong", metadata: ["error": "\(error)"])
```

However, since there is no clear preference for what metadata key to use, it is likely that different code bases use variations of the above. This makes it hard for automated tools to extract error information, since there is no single key to look for.

Additionally, there is more information that we could extract from the error, such as the type name.

```swift
logger.warning("Something went wrong", metadata: ["error.message": "\(error)", "error.type": "\(String(reflecting: type(of: error)))"])
```

The above is a reasonable way to log a generic error, but it is unlikely that everyone will use the same metadata keys. It is also quite a lot of code, for something that feels like it should be easy to do - i.e. attach an error to a log.

Finally, even if you log errors in a consistent way in your code, you do not control logs generated in other modules/packages that you call. In practice, this makes it so that different parts of your application could log error information under different keys, which, again, makes it harder for tooling.

### Proposed solution

The solution we propose is to add convenience methods in `Logger` that allows the caller to do the following:

```swift
do {
    try someThrowingFunc()
} catch {
    logger.warning("Something went wrong", error: error)
}
```

This would serialize the error, by stringifying it and extracting the fully qualified type name. This information is added as metadata, merging it with any metadata passed to the `metadata`-parameter. Under the hood, an existing log function is called with the merged metadata. We propose that such convenience methods are added for all log methods (even if it arguably makes less sense for e.g. `trace` and `debug` than `warning`). 

There are two clear gains from this:

* It is obvious for the caller _how_ to attach an `Error` to a log (and the caller code also looks cleaner)
* We get a consistent format for logged errors

Of course, it might take time for this feature to be widely adopted, but the proposed solution is fully backwards compatible, meaning there is no added downside of having some parts of your code calling the new convenience methods, and other parts manually attaching an error.

### Detailed design

The proposed solution is to add a new overload for each log method (`trace`, ..., `critical`) that accepts an `Error` as its second argument. Similarly, we add a new overload for `Logger.log`, that accepts an `Error` as its third argument.

```swift
public func trace(
    _ message: @autoclosure () -> Logger.Message,
        error: Error,
        metadata: @autoclosure () -> Logger.Metadata? = nil,
        source: @autoclosure () -> String? = nil,
        file: String = #fileID,
        function: String = #function,
        line: UInt = #line
    )

public func debug(
    _ message: @autoclosure () -> Logger.Message,
        error: Error,
        metadata: @autoclosure () -> Logger.Metadata? = nil,
        source: @autoclosure () -> String? = nil,
        file: String = #fileID,
        function: String = #function,
        line: UInt = #line
    )

public func info(
    _ message: @autoclosure () -> Logger.Message,
        error: Error,
        metadata: @autoclosure () -> Logger.Metadata? = nil,
        source: @autoclosure () -> String? = nil,
        file: String = #fileID,
        function: String = #function,
        line: UInt = #line
    )

public func notice(
    _ message: @autoclosure () -> Logger.Message,
        error: Error,
        metadata: @autoclosure () -> Logger.Metadata? = nil,
        source: @autoclosure () -> String? = nil,
        file: String = #fileID,
        function: String = #function,
        line: UInt = #line
    )

public func warning(
    _ message: @autoclosure () -> Logger.Message,
        error: Error,
        metadata: @autoclosure () -> Logger.Metadata? = nil,
        source: @autoclosure () -> String? = nil,
        file: String = #fileID,
        function: String = #function,
        line: UInt = #line
    )

public func error(
    _ message: @autoclosure () -> Logger.Message,
        error: Error,
        metadata: @autoclosure () -> Logger.Metadata? = nil,
        source: @autoclosure () -> String? = nil,
        file: String = #fileID,
        function: String = #function,
        line: UInt = #line
    )

public func critical(
        _ message: @autoclosure () -> Logger.Message,
        error: Error,
        metadata: @autoclosure () -> Logger.Metadata? = nil,
        source: @autoclosure () -> String? = nil,
        file: String = #fileID,
        function: String = #function,
        line: UInt = #line
    )

public func log(
        level: Logger.Level,
        _ message: @autoclosure () -> Logger.Message,
        error: Error,
        metadata: @autoclosure () -> Logger.Metadata? = nil,
        source: @autoclosure () -> String? = nil,
        file: String = #fileID,
        function: String = #function,
        line: UInt = #line
    )
```

We choose the keys `"error.message"` and `"error.type"` since they correspond to what [ECS](https://www.elastic.co/docs/reference/ecs/ecs-error) and [OpenTelemetry](https://opentelemetry.io/docs/specs/semconv/registry/attributes/error/#error-type) use.

We propose that the metadata keys used (`"error.message"` and `"error.type"`) should be considered stable and part of the `swift-log` API. This makes it so that `LogHandler`s can reliably access this information. This is useful if a `LogHandler` wants to output the logs in a format which uses other keys for error information (e.g. re-map the error to `"err.message"` and `"err.type"`).

However, it should be noted that users of `Logger` are still allowed to use the keys `"error"`, `"error.message"` and `"error.type"` manually. That is, both of the following are still valid.

```swift
logger.warning("Valid log", metadata: ["error": "\(error)"])
logger.warning("Valid log", metadata: ["error.message": ["msg1", "msg2"]])
```

This suggests that a `LogHandler` that wants to extract error information from the metadata must ensure that the expected types are passed. For example, it could opt to re-map any error metadata that contain only strings, and leave any other metadata using those keys untouched.

### API stability

The proposed additions are fully backwards compatible, meaning that all existing code will continue to function as is. Additionally, a user of `Logger` can start using the new convenience methods, without any modifications of the `LogHandler`, since a `LogHandler` is already expected to handle `Metadata`. 

If an `Error` is passed using the new convenience methods, and the same keys (`"error.message"`, `"error.type"`) are added as metadata on the logger (or on a metadata provider), it is up to the `LogHandler` how to merge these metadata. This is not a new issue, as the same may already happen today, if the caller manually serializes the error using those keys. Really, the only potential issue is if a caller uses the new methods to pass an `Error`, while also passing metadata with the same keys.

```swift
logger.warning("Something went wrong", error: error, metadata: ["error.message": "some other info"])
```

We suggest that in this case, the `error` takes precedence, and the `"error.message"` from `metadata` is discarded. We don't expect this to be an issue in reality. 

### Future directions

A future extension of this could be to pass raw `Error` objects to `LogHandler`s. This would allow them to extract more (or less) information from the `Error`, and serialize it however they want. One could imagine that such an extension would come with a default implementation similar to that in this proposal, so that existing `LogHandler`s would be unaffected.

This would however affect the abstraction layer between `Logger` and `LogHandler`, and so would need a strong justification.

### Alternatives considered

#### Public enum with well-known metadata keys

To make it easier for a `LogHandler` to extract error metadata, we could add an enum with the metadata key names.

```swift
extension Logger {
    public enum WellKnownMetadataKey: String {
        case errorMessage = "error.message"
        case errorType = "error.type"
    }
}
```

This also makes it easier to promote that these keys are part of the `swift-log` API.

#### Pass raw Error objects to LogHandler

An alternative would be to pass the `Error` objects directly to the `LogHandler` (as discussed in **"Future directions"**). This was the solution initially proposed in [apple/swift-log#384](https://github.com/apple/swift-log/pull/384). 

The API in `Logger` would be the same, adding new extensions methods that take an `Error` as a parameter, but would also allow a `LogHandler` to directly access the `Error` instance. 

```swift
struct CustomLogHandler: LogHandler {
    public func log(
        level: Logger.Level,
        message: Logger.Message,
        error: Error?, // New parameter
        metadata: Logger.Metadata?,
        source: String,
        file: String,
        function: String,
        line: UInt
    ) {
        // process log post and serialize error however you like
    }
}
```

This was rejected due to breaking the existing abstraction layer between `Logger` and `LogHandler`, while also being questionable how much value it would add.