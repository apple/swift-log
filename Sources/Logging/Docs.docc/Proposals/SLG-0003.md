# SLG-0003: Standardized Error Metadata via Logger Convenience

Add standardized way of attaching data from `Error` instances to log posts.

## Overview

- Proposal: SLG-0003
- Author(s): [Samuel Murray](https://github.com/samuelmurray)
- Status: **Awaiting Review**
- Issue: [apple/swift-log#291](https://github.com/apple/swift-log/issues/291)
- Implementation:
    - TBD
- Related links:
    - [Lightweight proposals process description](https://github.com/apple/swift-log/blob/main/Sources/Logging/Docs.docc/Proposals/Proposals.md)
    - [First attempt at solution](https://github.com/apple/swift-log/pull/384)

### Introduction

Add convenience methods on `Logger` that accepts an `Error` instance, which get serialized into `MetadataValue`s in a predefined way.

### Motivation

SwiftLog advocates for the use of _structured logging_, which in its implementation is achieved by using the `metadata` attribute in the log methods. This is important since it allows for automated tools to parse the logs and extract metadata values for filtering and/or visualization. When logging in a catch-block, it often makes sense to attach some information from the thrown `Error` in the log post, so as to capture the root cause.

```swift
do {
    try someThrowingFunc()
} catch {
    logger.warning("Something went wrong") // Want to somehow attach information about the error
}
```

Currently, there is no standardized way of doing this. The simplest way to do it would be to simply attach the stringified error to the message.

```swift
logger.warning("Something went wrong: \(error)")
```

This of course is not _structured_, so a better way would be:

```swift
logger.warning("Something went wrong", metadata: ["error": "\(error)"])
```

However, since there is no clear preference for what metadata key to use, it is likely that different code bases use variations of the above. This makes it hard for automated tools to extract error information, since there is no single key to look for.

Additionally, there is more information that we could extract from the error, such as the type name.

```swift
logger.warning("Something went wrong", metadata: ["error.message": "\(error)", "error.type": "\(String(reflecting: type(of: error)))"])
```

The above is a reasonable way to log a generic error, but it is unlikely that everyone will use the same metadata keys. It is also quite a lot of code, for something that feels like it should be easy to do - i.e. attach an error to a log.

Finally, even if you log errors in a consistent way in your code, you do not control logs generated in other modules/packages that you call. In practice, this makes it so that different parts of your application could log error information under different keys, which, again, makes it harder for tooling.

### Proposed solution

The solution we propose is to add convenience methods in `Logger` that allows the caller to do the following:

```swift
logger.warning("Something went wrong", error: error)
```

Under the hood, this would call 

```swift
logger.warning("Something went wrong", metadata: ["error.message": "\(error)", "error.type": "\(String(reflecting: type(of: error)))"])
```

i.e. it's a convenience wrapper of the existing methods. We propose that such convenience methods are added for all log methods (even if it arguably makes less sense for e.g. `trace` and `debug` than `warning`). 

There are two clear gains from this: 

* It is obvious for the caller _how_ to attach an `Error` to a log (and the caller code also looks cleaner)
* We get a consistent format for logged errors

Of course, it might take time for this feature to be adopted, but the proposed solution is fully backwards compatible, meaning there is no added downside of having some parts of your code calling the new convenience methods, and other parts manually attaching the error.

### Detailed design

The proposed solution is to add a new overload for `Logger.log`, that accepts an `Error` as its third argument and serializes it, adding the type and message to the `metadata` parameter.

Additionally, we add a new overload for each log method (`trace`, ..., `critical`) that accepts an `Error` as its second argument, that in turn calls the new `log` method.

```swift
public func log(
        level: Logger.Level,
        _ message: @autoclosure () -> Logger.Message,
        error: Error,
        metadata: @autoclosure () -> Logger.Metadata? = nil,
        source: @autoclosure () -> String? = nil,
        file: String = #fileID,
        function: String = #function,
        line: UInt = #line
    ) {
        self.log(
            level: level, 
            message(), 
            metadata: { 
                var metadata = metadata()
                metadata["error.type"] = "\(String(reflecting: type(of: error)))"
                metadata["error.message"] = "\(error)"
                return metadata
            }(),
            source: source(), 
            file: file, 
            function: function, 
            line: line
        )
    }

public func critical(
        _ message: @autoclosure () -> Logger.Message,
        error: Error,
        metadata: @autoclosure () -> Logger.Metadata? = nil,
        source: @autoclosure () -> String? = nil,
        file: String = #fileID,
        function: String = #function,
        line: UInt = #line
    ) {
        self.log(
            level: .critical,
            message(),
            error: error,
            metadata: metadata(),
            source: source(),
            file: file,
            function: function,
            line: line
        )
    }
```

We choose the keys `"error.message"` and `"error.type"` since they correspond to what [ECS](https://www.elastic.co/docs/reference/ecs/ecs-error) and [OpenTelemetry](https://opentelemetry.io/docs/specs/semconv/registry/attributes/error/#error-type) use.

We propose that the metadata keys used (`"error.message"` and `"error.type"`) should be considered stable and part of the `swift-log` API. This makes it so that `LogHandler`s can reliably access this information. This is useful if a `LogHandler` wants to output the logs in a format which uses other keys for error information.

### API stability

The proposed additions are fully backwards compatible, meaning that all existing code will continue to function as is. Additionally, a user of `Logger` can start using the new convenience methods, without any modifications of the `LogHandler`, since a `LogHandler` is already expected to handle `Metadata`. 

A `LogHandler` implementation is free to "ignore" the new metadata keys, and treat them as any other metadata. Alternatively, it can use the keys to e.g. re-map the error data to some other keys, such as `"err.message"` and `"err.type"`. However, it should be noted that only errors passed via the new convenience methods (or manually serialized using the same keys) will be captured this way. That is, the following is still valid:

```swift
logger.warning("Valid log", metadata: ["error": "\(error)"])
```

There is also no guarantee that the keys are not used manually with other data, i.e. the following is still valid (though unlikely to be an issue in reality):

```swift
logger.warning("Valid log", metadata: ["error.message": ["msg1", "msg2"]])
```

### Future directions

A future extension of this could be to pass raw `Error` objects to `LogHandler`s. This would allow them to extract more (or less) information from the `Error`, and serialize it however they want. One could imagine that such an extension would come with a default implementation similar to that in this proposal, so that existing `LogHandler`s would be unaffected.

This would however affect the abstraction layer between `Logger` and `LogHandler`, and so would need a strong justification.

### Alternatives considered

#### Pass raw Error objects to LogHandler

An alternative would be to pass the `Error` objects directly to the `LogHandler` (as discussed in **"Future directions"**). This was the solution initially proposed in [apple/swift-log#384](https://github.com/apple/swift-log/pull/384). 

The API in `Logger` would be the same, adding new extensions methods that take an `Error` as a parameter, but would also allow a `LogHandler` to directly access the `Error` instance. 

```swift
struct CustomLogHandler: LogHandler {
    public func log(
        level: Logger.Level,
        message: Logger.Message,
        error: Error?, // New parameter
        metadata: Logger.Metadata?,
        source: String,
        file: String,
        function: String,
        line: UInt
    ) {
        // process log post and serialize error however you like
    }
}
```

This was rejected due to breaking the existing abstraction layer between `Logger` and `LogHandler`, while also being questionable how much value it would add.